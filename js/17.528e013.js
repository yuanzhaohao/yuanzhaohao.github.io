(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[17],{74:function(n,o){n.exports={markdown:"<h2>基础篇-Javascript 面向对象</h2>\n<blockquote>\n<p>Javascript 面向对象是非常非常重要的内容，要掌握 Javascript 的面向对象编程，是一件不容易的事情，因为还要去学习很多关于设计模式的东西。目前还在钻研《Javascript 设计模式》，似乎任何一本与设计模式挂钩的书都不会容易呀！</p>\n</blockquote>\n<h4>创建对象的原始模式</h4>\n<pre><code class=\"language-javascript\">var person = new Object();\nperson.name = 'Yzh';\nperson.age = 21;\n</code></pre>\n<p>或者像这样：</p>\n<pre><code class=\"language-javascript\">var person = {\n  name: 'Yzh',\n  age: 21,\n};\n</code></pre>\n<p>上面创建对象的方法存在很大的不足：<strong>用一个接口创建很多实例，会产生大量的重复代码</strong>。</p>\n<h4>使用简单工厂模式</h4>\n<p>也就是在函数里面返回一个对象。</p>\n<pre><code class=\"language-javascript\">function createPerson(name, age) {\n  var o = new Object();\n  o.name = name;\n  o.age = age;\n  return o;\n}\nvar person1 = createPerson('Yzh', 21);\nvar person2 = createPerson('noone', 21);\n</code></pre>\n<p>上面的代码虽然解决了代码重复的问题，但是也还是存在很大的不足，那就是<strong>实例与实例之间没有任何什么联系</strong>。</p>\n<h4>使用构造函数模式</h4>\n<p>理解构造函数：其实构造函数本身也是函数。任何函数只要通过<code>new</code>操作符来调用，其实就是构造函数。因为通过<code>new</code>操作符来产生实例的时候，函数内部的<code>this</code>对象指向的是实例本身。不通过<code>new</code>操作符调用，和普通函数没有什么两样，下面举个例子：</p>\n<pre><code class=\"language-javascript\">function Person(name, age) {\n  this.name = name;\n  this.age = age;\n  this.sayName = function() {\n    console.log(this.name);\n  };\n}\n\n// 作为构造函数来使用\nvar person = new Person('Yzh', 21);\nperson.sayName();\n\n// 作为普通函数使用\nPerson('Yzh', 21);\nwindow.sayName();\n\n// 在别的对象的作用域里面调用\nvar o = {};\nPerson.call(o, 'noone', 21);\no.sayName();\n</code></pre>\n<p>上面的三种情况就是调用构造函数最常见的三种方式：1、使用 new 操作符；2、当作普通的函数来使用；3、在别的对象里面作用域里面调用；</p>\n<p>当使用第一种方式调用构造函数的时候，就可以解决上面说的<strong>实例与实例之间的问题</strong>。</p>\n<pre><code class=\"language-javascript\">function Person(name, age) {\n  this.name = name;\n  this.age = age;\n  this.sayName = function() {\n    console.log(this.name);\n  };\n}\nvar person1 = new Person('Yzh', 21);\nvar person2 = new Person('noone', 21);\n</code></pre>\n<p>上面的两个实例<code>person1</code>和<code>person2</code>都会拥有<code>constructor</code>的属性，用来指向构造函数本身。<code>console.log( person2.constructor === person1.constructor );</code></p>\n<p>另外前文也提到过<code>instanceof</code>操作符。</p>\n<pre><code class=\"language-javascript\">console.log(person1 instanceof Person);\nconsole.log(person2 instanceof Person);\nconsole.log(person1 instanceof Object);\n</code></pre>\n<p>上面代码执行的结果都是返回：true；</p>\n<p>但是使用构造函数模式也会有一些副作用：<strong>消耗更多的内存</strong>。</p>\n<p>原因很简单，看回 Person 构造函数，他里面有很多属性和方法，实际上每一个实例里面的这些属性和方法都是私有的，他们相同名称的属性和方法公用的是不同的内存。</p>\n<p>以上面的代码为例，person1 和 person2 有<code>sayName()</code>的方法，实际上 person1 和 person2 的<code>sayName()</code>方法是不一样的。</p>\n<p>那有没有可以让每一个实例的一些属性和方法共用相同的内存呢？答案就是<strong>原型对象</strong>；</p>\n<p>（今天先到这里吧，先回去了，怎么说今天也是中秋节，待会回去的路上买一个月饼尝尝，哈哈）</p>\n<h4>原型模式</h4>\n<p>我们创建的每一个函数都会有一个 prototype（原型）属性，指向函数的原型对象。原型对象会包含所有实例公用的属性和方法。</p>\n<pre><code class=\"language-javascript\">function Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\nPerson.prototype.sayName = function() {\n  console.log(this.name);\n};\nPerson.prototype.title = 'Love you';\nvar person1 = new Person('Yzh', 21),\n  person2 = new Person('noone', 21);\nconsole.log(person1.sayName === person2.sayName);\n</code></pre>\n<p>上面的例子中，person1 和 person2 的<code>sayName()</code>方法指向的是同样的内存。</p>\n<p><strong>理解原型对象</strong>：上面说了，每一个函数都会有 prototype（原型）属性，这个属性指向函数的原型对象。而该函数的原型对象上面又会有一个 constructor 属性指向该函数。</p>\n<p>当调用构造函数创建一个新的实例的时候，该实例内部会包含一个内部属性，指向构造函数的原型对象；ES5 里面把这个属性叫做[[Prototype]]，在高级浏览器里面，这个属性是可以通过<strong>proto</strong>来访问的。</p>\n<p>当访问实例某一个属性或者方法的时候，都会先搜索实例本身，看实例本身是否含有该属性或者方法，如果没有，则会去访问构造函数的原型对象，看看原型对象是否含有该属性或者方法。</p>\n<p>如果实例重写了某个属性，那么只要在实例里面能访问到该属性，就不会去搜索原型对象里面是否含有该属性。如果使用<code>delete</code>操作符删除了重写的该属性，那么访问到的将是原型对象里面的该属性。</p>\n<pre><code class=\"language-js\">person1.title = 'Love you forever';\nconsole.log(person1.title); // 'Love you forever'\nconsole.log(person2.title); // 'Love you'\n\ndelete person1.title;\nconsole.log(person1.title); // 'Love you'\n</code></pre>\n<p>下面介绍几个方法</p>\n<p>isPrototypeOf()：可以利用该函数确定实例与构造函数原型对象之间的关系；<code>console.log( Person.prototype.isPrototypeOf( person1 ) );</code></p>\n<p>hasOwnProperty()：判断实例里面是否含有自己独立的属性；</p>\n<pre><code class=\"language-js\">person1.title = 'Love you forever';\nconsole.log(person1.hasOwnProperty('title'));\n</code></pre>\n<p>in 操作符：判断某个对象是否含有某个属性，不管该属性是在实例上面，还是在原型对象上面。</p>\n<pre><code class=\"language-js\">console.log('title' in person2);\nconsole.log('title' in person1);\n</code></pre>\n<p>利用<code>in</code>操作符和<code>hasOwnProperty()</code>可以得到某一个属性是否是在原型对象上面。原理：当使用<code>hasOwnProperty()</code>返回 false，而使用 in 操作符返回 true 的时候，就可以得知该属性是在原型对象上面的。</p>\n<pre><code class=\"language-js\">function hasPrototypeProperty(obj, name) {\n  if (obj instanceof Object &amp;&amp; typeof name === 'string') {\n    return !obj.hasOwnProperty(name) &amp;&amp; name in obj;\n  }\n  return false;\n}\n</code></pre>\n<p>**原型模式的问题：**如果原型对象里面拥有引用类型的属性的话，那么只要一个实例修改了这个属性，那么所有创建的实例的该属性都会被改变，因为原型对象上面的属性是公有的。依然以上面的代码为例：</p>\n<pre><code class=\"language-js\">Person.prototype.friends = ['guoyalong', 'zhoubihan'];\nperson1.friends.push('dinglei');\nconsole.log(person2.friends);\n</code></pre>\n<p>上面代码的执行结果是：&quot;guoyalong&quot;, &quot;zhoubihan&quot;, &quot;dinglei&quot;；</p>\n<h4>使用构造函数模式和原型模式组合的模式</h4>\n<p>两种方法都有各自的局限和优点，那么将两种模式组合起来，就能解决各自的弊端，取长补短了。事实上，这种组合模式，是最常见的创建对象的方法。把私有的属性和方法在构造函数里面定义，而公有的属性和方法在原型对象上面定义。</p>\n<h4>继承之类式继承</h4>\n<p>回顾一下<strong>构造函数</strong>、<strong>原型对象</strong>、<strong>实例</strong>之间的联系：每一个构造函数里面都会有一个指向原型对象的属性 prototype，而原型对象里面又会有一个指向构造涵涵素的 constructor 属性，每一个实例里面都会有一个指向原型对象的内部属性[[Prototype]]</p>\n<pre><code class=\"language-js\">function Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\nfunction Author(name, age, book) {\n  this.name = name;\n  this.age = age;\n  this.book = book;\n}\n</code></pre>\n<p>**引入问题：**上面有两个构造函数，如果能让 Author 继承 Person 呢？</p>\n<p>**方法一：**使用 call 或者 apply</p>\n<pre><code class=\"language-js\">function Author(name, age, book) {\n  Person.call(this, name, age);\n  this.book = book;\n}\n\nvar a = new Author('Yzh', 21, 'My Blog');\nconsole.log(a.name);\n</code></pre>\n<p>上面会输出：Yzh</p>\n<p>**方法二：**使用原型链</p>\n<p>令子类的原型对象指向父类的一个实例；</p>\n<pre><code class=\"language-js\">function Person(name, age) {\n  this.name = name;\n  this.age = age;\n  this.sayName = function() {\n    console.log(this.name);\n  };\n}\nfunction Author(name, age, book) {\n  Person.call(this, name, age);\n  this.book = book;\n}\nAuthor.prototype = new Person();\nAuthor.prototype.constructor = Author;\nvar a = new Author('Yzh', 21, 'My Blog');\n</code></pre>\n<p>上面会输出：Yzh；</p>\n<p>因为子类 Author 的原型对象是父类 Person 的一个实例，因此 Author 继承了 Person 对象的方法和属性。</p>\n<p>但是有几点是需要注意的。</p>\n<p>当我们令子类的原型指向父类的实例的时候，就相当于重写了子类的原型属性，所以此时父类原型对象的 constructor 指向哪里，子类原型对象的 constructor 属性就指向哪里（上面的代码中，我们并没有在原型对象里面设置 constructor，所以 constructor 默认地指向了 Object，ps：看来哥的基础真的还还很烂），因此需要我们手动地把子类的原型对象的 constructor 指向子类。</p>\n<p>像上面的代码，如果没有<code>Author.prototype.constructor = Author;</code>，那么执行下面的代码就会出现 false 和 true 的结果。</p>\n<pre><code class=\"language-js\">console.log(Author.prototype.constructor === Author);\nconsole.log(Author.prototype.constructor === Object);\n</code></pre>\n<p><strong>直接继承父类原型</strong></p>\n<pre><code class=\"language-js\">function Person(name, age) {\n  this.name = name;\n  this.age = age;\n  this.sayName = function() {\n    console.log(this.name);\n  };\n}\nfunction Author(name, age, book) {\n  Person.call(this, name, age);\n  this.book = book;\n}\nAuthor.prototype = Person.prototype;\nAuthor.prototype.constructor = Author;\nvar a = new Author('Yzh', 21, 'My Blog');\n</code></pre>\n<p>与上面那种方法的比较，这种做法有明显的好处，这种方法并没有使用<code>new</code>操作符实例化一个实例，比较节省内存。但是这种做法也有很大的弊端，因为<code>Author.prototype = Person.prototype;</code>这里令子类和父类指向了同一个对象，因此，只要修改了子类原型对象，那么父类的原型对象也会被修改（实际上他们是同一个对象）。</p>\n<p>在这里，我们可以利用一个<strong>空函数作为中介</strong>，避免上面的弊端。</p>\n<pre><code class=\"language-js\">function Person(name, age) {\n  this.name = name;\n  this.age = age;\n  this.sayName = function() {\n    console.log(this.name);\n  };\n}\nPerson.prototype = {\n  constructor: Person,\n  sayAge: function() {\n    console.log(this.age);\n  },\n};\nfunction Author(name, age, book) {\n  Person.call(this, name, age);\n  this.book = book;\n}\nvar F = function() {};\nF.prototype = Person.prototype;\nAuthor.prototype = new F();\nAuthor.prototype.constructor = Author;\nconsole.log(Person.prototype.constructor === Person);\nvar a = new Author('Yzh', 21, 'My Blog');\na.sayName();\n</code></pre>\n<p>上面的代码中，由于 F 是空函数，所以几乎占用内存。（其实这里我也有一个地方不太明白，因为<code>sayName()</code>方法是父类的私有属性，为何子类继承父类之后，会有<code>sayName()</code>方法呢？啊，这个问题，当我看到了子类的构造函数的时候，顿时恍然大悟了，原来子类里面也利用<code>call()</code>继承了父类的私有属性）</p>\n<p>下面通过一个<code>extend()</code>函数来对上面的代码进行封装</p>\n<pre><code class=\"language-js\">function Person(name, age) {\n  this.name = name;\n  this.age = age;\n  this.sayName = function() {\n    console.log(this.name);\n  };\n}\nPerson.prototype = {\n  constructor: Person,\n  sayAge: function() {\n    console.log(this.age);\n  },\n};\nfunction Author(name, age, book) {\n  Person.call(this, name, age);\n  this.book = book;\n}\nfunction extend(subClass, superClass) {\n  var F = function() {};\n  F.prototype = superClass.prototype;\n  subClass.prototype = new F();\n  subClass.prototype.constructor = subClass;\n}\nextend(Author, Person);\n</code></pre>\n<p>**通过拷贝的方法实现继承：**通过拷贝父类原型对象的每一个属性到子类的原型对象里面（其实这个方法有点搓）</p>\n<pre><code class=\"language-js\">function prototypeCopy(subClass, superClass) {\n  var subP = subClass.prototype,\n    superP = superClass.prototype;\n\n  for (var p in superP) {\n    subP[p] = superP[p];\n  }\n}\n</code></pre>\n<h4>非类式继承</h4>\n<p>非类式继承和类式继承截然不同，当我们去讨论非类式继承的时候，应该只从对象的角度去思考。</p>\n<p><strong>使用 clone()函数</strong></p>\n<pre><code class=\"language-js\">var Person = {\n  name: 'Yzh',\n  sayName: function() {\n    return this.name;\n  },\n};\nfunction clone(obj) {\n  var F = function() {};\n  F.prototype = obj;\n  return new F();\n}\nvar render = clone(Person);\nconsole.log(render.name);\n</code></pre>\n<p>**浅拷贝：**所谓浅拷贝就是指把对象的每一个属性都拷给子类。</p>\n<pre><code class=\"language-js\">var person = {\n  name: 'Yzh',\n  sayName: function() {\n    return this.name;\n  },\n  friends: ['noone'],\n};\nfunction extendCopy(o) {\n  var sub = {};\n\n  for (var p in o) {\n    sub[p] = o[p];\n  }\n  return sub;\n}\nvar t = extendCopy(person);\nt.friends.push('cai');\nconsole.log(person.friends);\n</code></pre>\n<p>但这种方式只是把基本数据类型的数据拷贝过去，而像数组或者对象这样的引用类型，仅仅是把指针拷贝过去，因此像上面那样，当修改了 t 的 friends 属性的时候，person 也对被修改。</p>\n<p>所以像这样只是复制基本数据类型的方法我们称之为浅拷贝。</p>\n<p>**深拷贝：**其实就是递归利用浅拷贝来把各种数据复制过来。也就是实现真正意义上的数组和对象的拷贝。</p>\n<pre><code class=\"language-js\">function deepCopy(o, c) {\n  var c = arguments.length === 2 ? c : {};\n\n  for (var p in o) {\n    if (o[p] instanceof Object) {\n      c[p] = o[p] instanceof Array ? [] : {};\n      deepCopy(o[p], c[p]);\n    } else {\n      c[p] = o[p];\n    }\n  }\n  return c;\n}\nvar t2 = deepCopy(person);\nt2.friends.push('cai');\nconsole.log(t2.friends);\nconsole.log(person.friends);\n</code></pre>\n"}}}]);