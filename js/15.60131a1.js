(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[15],{123:function(e,t){e.exports={markdown:"<h2>基础篇-Javascript 事件处理</h2>\n<blockquote>\n<p>事件处理是 JS 里面很有趣的东西。今天我主要从事件流、事件处理程序（三种不同方式的事件处理程序）、不同的事件类型来介绍事件处理。</p>\n</blockquote>\n<h4>事件流</h4>\n<p>事件流描述的是从页面接收事件的顺序。分两种事件流，一是事件冒泡，二是事件捕获。</p>\n<p><strong>事件冒泡</strong>：就是指从事件开始触发的节点逐级向上传播到文档(document)</p>\n<pre><code class=\"language-html\">&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;简单的页面&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;p&gt;Helloworld!&lt;/p&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>像上面的代码，如果点击了上面的<code>p</code>标签，那么按照事件冒泡的处理方式，<code>click</code>事件实惠按照下面的顺序进行传播： <code>&lt;p&gt;</code> - <code>&lt;body&gt;</code> - <code>&lt;html&gt;</code> - <code>document</code></p>\n<p><strong>事件捕获</strong>：指从文档（document）逐级传播到事件开始触发的节点。</p>\n<p>而对于事件捕获来说，对于上面的代码，点击了<code>p</code>标签之后，则会按照完全相反的顺序进行传播：<code>document</code> - <code>&lt;html&gt;</code> - <code>&lt;body&gt;</code> - <code>&lt;p&gt;</code></p>\n<h4>事件处理程序</h4>\n<h5>html 代码指定事件处理程序</h5>\n<p>首先，对于我们每一个学习网站开发的人来说，下面的代码，一定都会有所接触。</p>\n<pre><code class=\"language-html\">&lt;input type=&quot;button&quot; value=&quot;click me&quot; name=&quot;click&quot; onclick=&quot;alert( this.name );&quot; /&gt;\n</code></pre>\n<p>这样的代码实际上有很多不好的地方。</p>\n<p>第一，如果用户在页面解析<code>onclick</code>里面指定代码之前就点击触发里面的代码，那么就会引发错误。</p>\n<p>解决办法：设置<code>try{ } catch ( ex ) { }</code></p>\n<pre><code>&lt;input type=&quot;button&quot; value=&quot;click me&quot; name=&quot;click&quot; onclick=&quot;try{ alert( this.name ); } catch ( ex ) { }&quot; /&gt;\n</code></pre>\n<p>第二，HTML 代码和 Javascript 代码紧密耦合。</p>\n<p>上面这种添加事件处理的写法非常不好，我们应该摒弃它。</p>\n<h5>DOM0 级事件处理程序</h5>\n<p>这种方式也就是讲一个函数赋值给一个事件处理程序属性。</p>\n<pre><code class=\"language-js\">var btn = document.getElementById('tx');\nbtn.onclick = function() {\n  console.log('clicked');\n  console.log(this === btn); // true\n};\n</code></pre>\n<p>删除该事件处理程序，只要把该属性设置为 null 就可以了。<code>btn.onclick = null;</code></p>\n<p>使用 DOM0 级事件处理程序，需要注意以下几点：</p>\n<p>1、这种方式只可以添加一个事件处理程序，如果添加多个，那么后面的添加的将会覆盖前面添加的。</p>\n<p>2、这种方式添加事件处理程序，函数的作用域是绑定在添加事件的元素上的。</p>\n<h5>DOM2 级事件处理程序</h5>\n<p>DOM2 级事件处理程序定义了两个函数：<code>addEventListener()</code>和<code>removeEventListener()</code>；两者都是接收三个参数：事件名称、事件处理程序、是否在捕获阶段调用事件处理程序（true 为在捕获阶段调用事件处理程序，false 为在冒泡阶段调用事件处理程序）</p>\n<pre><code class=\"language-js\">btn.addEventListener(\n  'click',\n  function() {\n    console.log('clicked'); // 'clicked'\n    console.log(this === btn); // true\n  },\n  false,\n);\n</code></pre>\n<p>有两点需要注意的是：</p>\n<p>1、这种方式的事件处理程序的作用域一般是在绑定事件的元素上面；</p>\n<p>2、这种方式支持添加多个事件处理程序，而且执行的顺序是按照添加程序的先后顺序来的（有点类似于队列那样，先进先出）。</p>\n<p>3、很多同学都认为 IE 不支持这种事件处理程序，其实 IE9、IE10 以及刚刚出来的 IE11 都是已经支持的了。支持这种事件处理程序的浏览器包括：IE9+、Firefox、Safari、Chrome 和 Opera。</p>\n<p>4、利用<code>addEventListener()</code>添加事件处理程序，只能通过<code>removeEventListener()</code>来移除，举个例子，上面的代码中，添加的是匿名函数，那么使用<code>removeEventListener()</code>是无法移除的哈，<code>removeEvnetListener()</code>是移除同名的事件处理函数。</p>\n<h5>IE 事件处理程序</h5>\n<p>IE 事件处理程序中，也有两个类似于 DOM2 级事件处理程序的函数：<code>attachEvent()</code>和<code>detachEvent()</code>。这两个函数都支持两个参数：事件名称以及事件处理程序函数。</p>\n<pre><code class=\"language-js\">var btn = document.getElementById('tx');\nbtn.attachEvent('onclick', function() {\n  alert('clicked');\n  alert(window === this);\n});\nbtn.attachEvent('onclick', function() {\n  alert('clicked2');\n});\n</code></pre>\n<p>需要注意以下几点：</p>\n<p>1、事件处理程序可以添加多个，但是执行顺序是按照添加顺序的相反顺序执行的（有点类似于栈了，先进后出）</p>\n<p>2、事件处理程序函数的作用域是全局作用域；</p>\n<p>3、支持这种事件处理程序的主流浏览器不仅仅是 IE 哦，还有 Opera</p>\n<p>4、有点类似于 DOM2 级事件处理程序了，用<code>attachEvent()</code>添加的事件处理程序，只能用<code>dettachEvent()</code>来移除。</p>\n<h5>事件对象</h5>\n<p>所谓事件对象就是指触发 DOM 上的某个事件的时候，会产生一个事件对象 event；我觉得事件对象大概是事件处理程序里面最有趣的东西了，尤其是 DOM 中的事件对象，提供了很多有趣的属性；</p>\n<p><strong>DOM 中的事件对象</strong>：支持 DOM 事件处理程序的浏览器会传入一个 event 对象；</p>\n<p>下面简单介绍几个 DOM 中 event 对象有趣的属性：</p>\n<p><strong>currentTarget 和 target</strong>：</p>\n<p>currentTarget 是指当前事件处理程序正在处理的那个元素，在事件处理程序内部，this 始终和 currentTarget 相等。</p>\n<p>target 是指事件的目标；</p>\n<p>如果直接把事件处理程序指定给目标元素，则 this、currentTarget 和 target 包含相同的值。</p>\n<pre><code class=\"language-js\">btn.addEventListener(\n  'click',\n  function(event) {\n    console.log(this === event.currentTarget);\n    console.log(this === event.target);\n  },\n  false,\n);\n</code></pre>\n<p>上面的结果会返回两个<code>true</code>。</p>\n<pre><code class=\"language-js\">btn.addEventListener(\n  'click',\n  function(event) {\n    console.log(this === event.currentTarget);\n    console.log(this === event.target);\n  },\n  false,\n);\n\nbody.addEventListener(\n  'click',\n  function(event) {\n    console.log(body === event.currentTarget);\n    console.log(btn === event.target);\n  },\n  false,\n);\n</code></pre>\n<p>如果点击了 btn 按钮，那么将会输出：true、true、true、true；如果点击的是非 btn 的里面的东西，那么就会返回 true、false；</p>\n<p><strong>stopPropagation()</strong>：这个方法用于停止事件在 DOM 中的传播。</p>\n<p>以上的代码为例：如果加入在 btn 的事件处理程序里面加入<code>event.stopPropagation()</code>，那么点击 btn 之后，是不会出现后面两个 true 的，因为这个方法已经阻止事件的冒泡行为。</p>\n<p><strong>preventDefault()</strong>：这个方法是用于元素阻止默认的行为。</p>\n<p>举个最简单的例子，如果在一个 a 标签上面设置了 click 事件，而这个事件处理程序里面有<code>event.preventDefault()</code>方法的话，那么 a 标签里面设置的 href 是没有效果的，因为已经阻止了默认的行为。</p>\n<p><strong>IE 中的事件对象</strong></p>\n<p>IE 里面的事件对象的获取有两种方式，如果没有为事件处理函数传入 event 对象，那么可以通过 window 对象来访问 event 对象。也就是<code>window.event</code></p>\n<p><strong>IE 中事件对象的一些有趣属性和方法</strong></p>\n<p>上面提到 DOM 里面有<code>stopPropagation()</code>和<code>preventDefault()</code>方法，那么在 IE 的事件对象里面也有对应的方法或者属性来实现类似的效果，那就是<code>cancelBubble</code>和<code>returnValue</code>；</p>\n<p>当<code>cancelBubble</code>变成<code>true</code>的时候（当然，它的默认值是 false），就会阻止事件处理程序的冒泡。</p>\n<p>当<code>returnValue</code>变成<code>false</code>的时候，就会阻止元素的默认行为。</p>\n<p>对，还有一个很有趣的属性，和 DOM 中 target 相对应的属性，说到这里，大家应该也猜到是获取事件目标的的属性了，没错，那就是<code>srcElement</code>。是 IE 中的事件对象获取事件目标的属性。</p>\n<p><strong>兼容 DOM 和 IE 的事件模块</strong></p>\n<pre><code class=\"language-js\">    function EventClass() {\n\n    }\n    EventClass.prototype = {\n    \tconstructor: EventClass,\n    \taddEvent: function( elem, type, handler ) {\n    \t\tif( document.addEventListener ) {\n    \t\t\telem.addEventListener( type, handler, false );\n    \t\t} else if( document.attachEvent ) {\n    \t\t\tvar f = handler.call( elem );\n    \t\t\telem.attachEvent( 'on'+type, f );\n    \t\t} else {\n    \t\t\telem.'on'+type = handler;\n    \t\t}\n    \t},\n    \tremoveEvent: function() {\n    \t\tif( document.removeEventListener ) {\n    \t\t\telem.removeEventListener( type, handler, false );\n    \t\t} else if( document.detachEvent ) {\n    \t\t\tvar f = handler.call( elem );\n    \t\t\telem.detachEvent( 'on'+type, f );\n    \t\t} else {\n    \t\t\telem.'on'+type = null;\n    \t\t}\n    \t},\n    \tgetEvent: function( event ) {\n    \t\treturn event ? event : window.event;\n    \t},\n    \tgetTarget: function( event ) {\n    \t\treturn event.target || event.srcElement;\n    \t},\n    \tstopPropagation: function( event ) {\n    \t\tevent.stopPropagation ? event.stopPropagation() : event.cancelBubble = true;\n    \t},\n    \tpreventDefault: function( event ) {\n    \t\tevent.preventDefault ? event.preventDefault() : event.returnValue = false;\n    \t}\n    };\n</code></pre>\n<p>（写得相对比较简单，哈哈。后面还会谈很多和事件处理有关的知识，熟话说：温故而知新。这句话还是说得很有道理的。不管怎么样，follow my heart，只要问心无愧就好！）</p>\n"}}}]);