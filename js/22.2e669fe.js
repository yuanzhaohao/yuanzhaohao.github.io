(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[22],{79:function(e,n){e.exports={markdown:"<h2>redux 工作原理解读</h2>\n<blockquote>\n<p>随着 web 开发日趋复杂，前端需要管理比任何时候都要多的 state（状态）。redux 应运而生，基本思想是保证数据的单向流动，同时便于控制、使用、测试。</p>\n</blockquote>\n<p>参考官网的<a href=\"https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/counter\">例子</a>，简单讲讲。</p>\n<pre><code class=\"language-js\">import { createStore } from 'redux';\n\nfunction count(state = 0, action) {\n  switch (action.type) {\n    case 'INCREMENT':\n      return state + 1;\n    case 'DECREMENT':\n      return state - 1;\n    default:\n      return state;\n  }\n}\n\n// store的创建\nconst store = createStore(count);\n\n// store里面的数据发生改变时，触发的回调函数\nstore.subscribe(function() {\n  console.log('current state is: ', store.getState());\n});\n\n// 改变store里面的方法\nstore.dispatch({ type: 'INCREMENT' }); // current state is: 1\nstore.dispatch({ type: 'INCREMENT' }); // current state is: 2\nstore.dispatch({ type: 'DECREMENT' }); // current state is: 3\n</code></pre>\n<h4>createStore 的实现</h4>\n<p>上面的例子可以看出，<code>createStore</code>作为生成 sore 的函数，是 redux 中比较核心的 API。我们直接看看其源码</p>\n<pre><code class=\"language-js\">import $$observable from 'symbol-observable';\n\nimport ActionTypes from './utils/actionTypes';\nimport isPlainObject from './utils/isPlainObject';\n\nexport default function createStore(reducer, preloadedState, enhancer) {\n  if (\n    (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'function') ||\n    (typeof enhancer === 'function' &amp;&amp; typeof arguments[3] === 'function')\n  ) {\n    throw new Error(\n      'It looks like you are passing several store enhancers to ' +\n        'createStore(). This is not supported. Instead, compose them ' +\n        'together to a single function.',\n    );\n  }\n\n  if (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'undefined') {\n    enhancer = preloadedState;\n    preloadedState = undefined;\n  }\n\n  if (typeof enhancer !== 'undefined') {\n    if (typeof enhancer !== 'function') {\n      throw new Error('Expected the enhancer to be a function.');\n    }\n\n    return enhancer(createStore)(reducer, preloadedState);\n  }\n\n  if (typeof reducer !== 'function') {\n    throw new Error('Expected the reducer to be a function.');\n  }\n\n  let currentReducer = reducer;\n  let currentState = preloadedState;\n  let currentListeners = [];\n  let nextListeners = currentListeners;\n  let isDispatching = false;\n\n  function ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice();\n    }\n  }\n\n  function getState() {\n    if (isDispatching) {\n      throw new Error(\n        'You may not call store.getState() while the reducer is executing. ' +\n          'The reducer has already received the state as an argument. ' +\n          'Pass it down from the top reducer instead of reading it from the store.',\n      );\n    }\n\n    return currentState;\n  }\n\n  function subscribe(listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('Expected the listener to be a function.');\n    }\n\n    if (isDispatching) {\n      throw new Error(\n        'You may not call store.subscribe() while the reducer is executing. ' +\n          'If you would like to be notified after the store has been updated, subscribe from a ' +\n          'component and invoke store.getState() in the callback to access the latest state. ' +\n          'See https://redux.js.org/api-reference/store#subscribelistener for more details.',\n      );\n    }\n\n    let isSubscribed = true;\n\n    ensureCanMutateNextListeners();\n    nextListeners.push(listener);\n\n    return function unsubscribe() {\n      if (!isSubscribed) {\n        return;\n      }\n\n      if (isDispatching) {\n        throw new Error(\n          'You may not unsubscribe from a store listener while the reducer is executing. ' +\n            'See https://redux.js.org/api-reference/store#subscribelistener for more details.',\n        );\n      }\n\n      isSubscribed = false;\n\n      ensureCanMutateNextListeners();\n      const index = nextListeners.indexOf(listener);\n      nextListeners.splice(index, 1);\n      currentListeners = null;\n    };\n  }\n\n  function dispatch(action) {\n    if (!isPlainObject(action)) {\n      throw new Error(\n        'Actions must be plain objects. ' + 'Use custom middleware for async actions.',\n      );\n    }\n\n    if (typeof action.type === 'undefined') {\n      throw new Error(\n        'Actions may not have an undefined &quot;type&quot; property. ' + 'Have you misspelled a constant?',\n      );\n    }\n\n    if (isDispatching) {\n      throw new Error('Reducers may not dispatch actions.');\n    }\n\n    try {\n      isDispatching = true;\n      currentState = currentReducer(currentState, action);\n    } finally {\n      isDispatching = false;\n    }\n\n    const listeners = (currentListeners = nextListeners);\n    for (let i = 0; i &lt; listeners.length; i++) {\n      const listener = listeners[i];\n      listener();\n    }\n\n    return action;\n  }\n\n  function replaceReducer(nextReducer) {\n    if (typeof nextReducer !== 'function') {\n      throw new Error('Expected the nextReducer to be a function.');\n    }\n\n    currentReducer = nextReducer;\n    dispatch({ type: ActionTypes.REPLACE });\n  }\n\n  function observable() {\n    const outerSubscribe = subscribe;\n    return {\n      subscribe(observer) {\n        if (typeof observer !== 'object' || observer === null) {\n          throw new TypeError('Expected the observer to be an object.');\n        }\n\n        function observeState() {\n          if (observer.next) {\n            observer.next(getState());\n          }\n        }\n\n        observeState();\n        const unsubscribe = outerSubscribe(observeState);\n        return { unsubscribe };\n      },\n\n      [$$observable]() {\n        return this;\n      },\n    };\n  }\n\n  dispatch({ type: ActionTypes.INIT });\n\n  return {\n    dispatch,\n    subscribe,\n    getState,\n    replaceReducer,\n    [$$observable]: observable,\n  };\n}\n</code></pre>\n<p>我们先看看<code>createStore</code>返回什么内容:</p>\n<pre><code class=\"language-js\">return {\n  dispatch,\n  subscribe,\n  getState,\n  replaceReducer,\n  [$$observable]: observable,\n};\n</code></pre>\n<p>每个属性的含义是:</p>\n<ul>\n<li>dispatch: 用于 action 的分发</li>\n<li>subscribe: 注册 listener，store 里面 state 发生改变后，执行该 listener</li>\n<li>getState: 读取 store 当前的 state</li>\n<li>replaceReducer: 替换 reducer，改变 state 修改的逻辑</li>\n</ul>\n<p>再看看输入端的参数：</p>\n<ul>\n<li>reducer: 用来描述 action 如何改变 state，改变 store 里面的 state</li>\n<li>preloadedState: 可以是初始化的 state，也可以是 enhancer。若传入的参数是<code>function</code>，则会替代 enhancer，否则是初始化的 state。</li>\n<li>enhancer: 是一个高阶函数，用于拓展 store 的功能，如 redux 自带的模块<code>applyMiddleware</code>就是一个 enhancer 函数。</li>\n</ul>\n<h5>enhancer</h5>\n<p>这里需要解释一下<code>enhancer</code>的作用。一个 store enhancer，实际上就是一个高阶函数，它的参数是创建 store 的函数（store creator），返回值是一个可以创建功能更加强大的 store 的函数(enhanced store creator)，这和 React 中的高阶组件的概念很相似。store enhancer 函数的结构一般如下：</p>\n<pre><code class=\"language-js\">function enhancerCreator() {\n  return createStore =&gt; (reducer, initialState, enhancer) =&gt; {\n    // do something based old store\n    return { ...store, dispatch }; // return a new enhanced store\n  };\n}\n</code></pre>\n<p>每一个 enhancer 都会改变默认的 dispatch，redux 里 enhancer 的源码如下：</p>\n<pre><code class=\"language-js\">if (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'undefined') {\n  enhancer = preloadedState;\n  preloadedState = undefined;\n}\n\nif (typeof enhancer !== 'undefined') {\n  if (typeof enhancer !== 'function') {\n    throw new Error('Expected the enhancer to be a function.');\n  }\n\n  return enhancer(createStore)(reducer, preloadedState);\n}\n</code></pre>\n<h4>subscribe &amp; dispatch</h4>\n<p>下面说下 subscribe 方法，请看源码：</p>\n<pre><code class=\"language-js\">function subscribe(listener) {\n  if (typeof listener !== 'function') {\n    throw new Error('Expected the listener to be a function.');\n  }\n\n  if (isDispatching) {\n    throw new Error(\n      'You may not call store.subscribe() while the reducer is executing. ' +\n        'If you would like to be notified after the store has been updated, subscribe from a ' +\n        'component and invoke store.getState() in the callback to access the latest state. ' +\n        'See https://redux.js.org/api-reference/store#subscribelistener for more details.',\n    );\n  }\n\n  let isSubscribed = true;\n\n  ensureCanMutateNextListeners();\n  nextListeners.push(listener);\n\n  return function unsubscribe() {\n    if (!isSubscribed) {\n      return;\n    }\n\n    if (isDispatching) {\n      throw new Error(\n        'You may not unsubscribe from a store listener while the reducer is executing. ' +\n          'See https://redux.js.org/api-reference/store#subscribelistener for more details.',\n      );\n    }\n\n    isSubscribed = false;\n\n    ensureCanMutateNextListeners();\n    const index = nextListeners.indexOf(listener);\n    nextListeners.splice(index, 1);\n    currentListeners = null;\n  };\n}\n</code></pre>\n<p>subscribe 函数实现了一个订阅机制，在 subscribe 函数传入 listener 回调函数，然后在 dispatch 的时候执行这些 listeners。值得一提的是，subscribe 函数的返回值是一个 unsubscribe 函数，用于接触该 listener 的订阅。</p>\n<p>dispatch 方法，通过 action 该改变 state，然后执行 subscribe 注册的方法。</p>\n<pre><code class=\"language-js\">function dispatch(action) {\n  if (!isPlainObject(action)) {\n    throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');\n  }\n\n  if (typeof action.type === 'undefined') {\n    throw new Error(\n      'Actions may not have an undefined &quot;type&quot; property. ' + 'Have you misspelled a constant?',\n    );\n  }\n\n  if (isDispatching) {\n    throw new Error('Reducers may not dispatch actions.');\n  }\n\n  try {\n    isDispatching = true;\n    currentState = currentReducer(currentState, action);\n  } finally {\n    isDispatching = false;\n  }\n\n  const listeners = (currentListeners = nextListeners);\n  for (let i = 0; i &lt; listeners.length; i++) {\n    const listener = listeners[i];\n    listener();\n  }\n\n  return action;\n}\n</code></pre>\n<p>replaceReducer 方法用于动态更新当前 currentReducer 。 通过对外暴露 replaceReducer API, 外部可以直接调用这个方法来替换当前 currentReducer</p>\n<pre><code class=\"language-js\">function replaceReducer(nextReducer) {\n  if (typeof nextReducer !== 'function') {\n    throw new Error('Expected the nextReducer to be a function.');\n  }\n\n  currentReducer = nextReducer;\n  dispatch({ type: ActionTypes.REPLACE });\n}\n</code></pre>\n<h4>combineReducers</h4>\n<p>顾名思义，combineReducers 作用是将多个 reducer 合并成一个 reducer 并传入 createStore 函数。</p>\n<pre><code class=\"language-js\">function combineReducers(reducers) {\n  const reducerKeys = Object.keys(reducers);\n  const finalReducers = {};\n  // 首先会过滤不合法的reducer\n  for (let i = 0; i &lt; reducerKeys.length; i++) {\n    const key = reducerKeys[i];\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof reducers[key] === 'undefined') {\n        warning(`No reducer provided for key &quot;${key}&quot;`);\n      }\n    }\n\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key];\n    }\n  }\n  const finalReducerKeys = Object.keys(finalReducers);\n\n  let unexpectedKeyCache;\n  if (process.env.NODE_ENV !== 'production') {\n    unexpectedKeyCache = {};\n  }\n\n  let shapeAssertionError;\n  try {\n    assertReducerShape(finalReducers);\n  } catch (e) {\n    shapeAssertionError = e;\n  }\n\n  // 返回一个combination方法 这个方法传入state 和action  返回一个新的状态树\n  return function combination(state = {}, action) {\n    if (shapeAssertionError) {\n      throw shapeAssertionError;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      const warningMessage = getUnexpectedStateShapeWarningMessage(\n        state,\n        finalReducers,\n        action,\n        unexpectedKeyCache,\n      );\n      if (warningMessage) {\n        warning(warningMessage);\n      }\n    }\n\n    let hasChanged = false;\n    const nextState = {};\n    for (let i = 0; i &lt; finalReducerKeys.length; i++) {\n      const key = finalReducerKeys[i];\n      const reducer = finalReducers[key];\n      const previousStateForKey = state[key];\n      const nextStateForKey = reducer(previousStateForKey, action);\n      if (typeof nextStateForKey === 'undefined') {\n        const errorMessage = getUndefinedStateErrorMessage(key, action);\n        throw new Error(errorMessage);\n      }\n      nextState[key] = nextStateForKey;\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n    }\n    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;\n    return hasChanged ? nextState : state;\n  };\n}\n</code></pre>\n<h4>bindActionCreator</h4>\n<p>在上面的 demo 中，要执行 state 的改变，需要手动 dispatch。为了减少手动操作 dispatch 操作，redux 提供了<code>bindActionCreator</code>把 action creators 转化成一个可以执行 dispatch 的函数。</p>\n<pre><code class=\"language-js\">function bindActionCreator(actionCreator, dispatch) {\n  return function() {\n    return dispatch(actionCreator.apply(this, arguments));\n  };\n}\n\nexport default function bindActionCreators(actionCreators, dispatch) {\n  if (typeof actionCreators === 'function') {\n    return bindActionCreator(actionCreators, dispatch);\n  }\n\n  if (typeof actionCreators !== 'object' || actionCreators === null) {\n    throw new Error(\n      `bindActionCreators expected an object or a function, instead received ${\n        actionCreators === null ? 'null' : typeof actionCreators\n      }. ` +\n        `Did you write &quot;import ActionCreators from&quot; instead of &quot;import * as ActionCreators from&quot;?`,\n    );\n  }\n\n  const boundActionCreators = {};\n  for (const key in actionCreators) {\n    const actionCreator = actionCreators[key];\n    if (typeof actionCreator === 'function') {\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\n    }\n  }\n  return boundActionCreators;\n}\n</code></pre>\n<p>举个例子，比如 actions.js</p>\n<pre><code class=\"language-js\">export function increment() {\n  return {\n    type: 'INCREMENT',\n  };\n}\nexport function decrement() {\n  return {\n    type: 'DECREMENT',\n  };\n}\n</code></pre>\n<p>经过<code>bindActionCreators</code>转化后，就会变成：</p>\n<pre><code class=\"language-js\">{\n  increment: () =&gt; dispatch(decrement());\n  decrement: () =&gt; dispatch(decrement());\n}\n</code></pre>\n<p><code>react-redux</code>里的 connect 组件的第二个参数<code>mapDispatchToProps</code>会调用这个方法对 action 进行转换。</p>\n<h4>compose &amp; applyMiddleware</h4>\n<p>上面也提及，applyMiddleware 实际上是一个 enhancer，用于增强 store 的 dispatch 功能。这个函数实际上是实现了函数式编程中的柯里化</p>\n<pre><code class=\"language-js\">export default function applyMiddleware(...middlewares) {\n  return createStore =&gt; (...args) =&gt; {\n    const store = createStore(...args);\n    let dispatch = () =&gt; {\n      throw new Error(\n        'Dispatching while constructing your middleware is not allowed. ' +\n          'Other middleware would not be applied to this dispatch.',\n      );\n    };\n\n    const middlewareAPI = {\n      getState: store.getState,\n      dispatch: (...args) =&gt; dispatch(...args),\n    };\n    const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI));\n    dispatch = compose(...chain)(store.dispatch);\n\n    return {\n      ...store,\n      dispatch,\n    };\n  };\n}\n</code></pre>\n<p>下面是 compose 的源码</p>\n<pre><code class=\"language-js\">export default function compose(...funcs) {\n  if (funcs.length === 0) {\n    return arg =&gt; arg;\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n\n  return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)));\n}\n</code></pre>\n<p>核心的代码在于<code>funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))</code>，compose 函数的作用在于将 chain 中的所有匿名函数，[f1, f2, ... , fx, ..., fn]，组装成一个新的函数，即新的 dispatch，当新 dispatch 执行时，[f1, f2, ... , fx, ..., fn]，从右到左依次执行（ 所以顺序很重要）。举个例子，加入 n=3，当 compose 执行完后，我们得到的 dispatch 是这样的：</p>\n<pre><code class=\"language-js\">dispatch = f1(f2(f3(store.dispatch))))\n</code></pre>\n<h4>与 React 搭配</h4>\n<p>React 有 props 和 state，props 是父级分发下来的属性，state 是组件内部可以自行管理的状态。但是 React 没有数据向上回溯的能力，数据只能单向向下分发，或者自行内部消化。</p>\n<p>redux 的出现，能够更好地对 state 进行管理，通过集中化 state 到所有组件最顶层，然后分发给所有组件。为了结合 React 和 redux，我们一般会用<code>react-redux</code>工具。</p>\n<p>这个工具的核心有两个：</p>\n<ul>\n<li>Provider: 是一个通过 React 的 context api 实现的组件，作为应用顶层的入口，需要把 redux 的 store 传入</li>\n<li>connect: 是一个高阶函数，接受<code>mapStateToProps</code>和<code>mapDispatchToProps</code>这两个核心参数。\n<ul>\n<li>mapStateToProps: 需要绑定一个函数，它的参数是 state，最后会 return 你需要的 state。</li>\n<li>mapDispatchToProps: 这个参数可以是对象或者是函数。主要作用是分发 action。如果是对象，必须是 actionCreators 对象，就像上面的 demo 那样。</li>\n</ul>\n</li>\n</ul>\n"}}}]);