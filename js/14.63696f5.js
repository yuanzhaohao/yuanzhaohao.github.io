(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[14],{124:function(n,e){n.exports={markdown:"<h2>基础篇-Javascript 基础</h2>\n<blockquote>\n<p>希望自己在写这篇博客的时候，能认真、细致、深入地去了解 Javascript 这一门语言的精髓。任何时候，只有自己心里静下来的时候，才能够细致地进行思考。在写这篇博客的时候，我也希望自己能真正地让自己的心静下来，不得不说，自己的心最近真有点浮躁！</p>\n</blockquote>\n<h4>Javascript 的组成</h4>\n<p>一个完整的 Javascript 应该由以下三部分组成：</p>\n<ul>\n<li>核心（ECMAScript）</li>\n<li>文档对象模型（DOM）</li>\n<li>浏览器对象对象模型（BOM）</li>\n</ul>\n<p><img src=\"/static/img/javascript-composition.png\" alt=\"javascript-composition\"></p>\n<h5>ECMAScript</h5>\n<p>ECMAScript 是通过 ECMA-262 标准化的脚本程序设计语言。ECMA-262 定义的只是这门语言的基础，而在此基础上可以构建更完善的脚本语言。另外，值得一提的是，Web 浏览器只是 ECMAScript 实现的<strong>宿主环境</strong>之一。</p>\n<p>ECMAScript 至今已经出现 6 个版本了，今年 5 月份吧，ECMAScript 已经出来第六版了。（其实本人对 ECMAScript6 规法也不是很了解，因为刚出来没多久，有空再去看看浏览器对它的支持吧！）</p>\n<h5>DOM</h5>\n<p>文档对象模型是针对 XML 但经过扩展用于 HTML 的 API。DOM 把整个页面映射成一个多层节点结构。</p>\n<pre><code class=\"language-html\">&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;简单的页面&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;p&gt;Helloworld!&lt;/p&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>在 DOM 中，上面的 html 代码会被映射成一个分层节点图。</p>\n<p><img src=\"/static/img/javascript-tree.png\" alt=\"javascript-tree\"></p>\n<p>所谓 DOM（Document Object Model）操作，我觉得就是指通过 DOM 这套 API，把文档节点转换成对象；</p>\n<p>值得注意的是，并不是只针对 Javascript，很多其它语言也都可以实现 DOM；</p>\n<h5>BOM</h5>\n<p>支持可以访问和操作浏览器窗口的浏览器对象模型，提供与浏览器交互的方法和接口；</p>\n<h4>ECMAScript 语法基础</h4>\n<h5>数据类型</h5>\n<p>ECMAScript 有 5 种简单数据类型（Undefined、Null、Boolean、Number、String）和 1 种复杂数据类型（Object）</p>\n<p>由于 Javascript 是松散类型的，因此我们在使用这些数据类型的时候，有必要对这些数据类型进行判断。在判断数据类型的时候，undefined、number、String，我都会用 typeof 进行判断：<code>if( typeof n1 === 'string' )</code></p>\n<p>还有 function，我也是用 typeof 来判断，对于引用类型，比如 Object、Array 等，我一般会用 instanceof 来判断。</p>\n<p>在判断函数参数的时候，这样的语法必须要杜绝<code>if( n1 )</code> or like this <code>if( n1 != null )</code> and so on.</p>\n<p>上面的例子非常不好（<strong>我认为学习编程一段时间后，所追求的就不能是实现功能那么简单，更多的要学会如何去优化自己的代码；这里就再扯一句我自己的观点：要学好一门语言，关键在于两点：基础和思想；把基础学好自然不用说，把开发思想学好，能让我们在项目开发中，处于一个大局观，针对不同的项目，可以使用不同的开发思想。</strong>）</p>\n<h5>Number 篇</h5>\n<p>说到 number 类型，我第一个想到的是一个很特殊的 NaN，也就是 Not a Number。</p>\n<p>NaN 是一个很特殊的数值，是 ES1 引入的一个变量，是全局作用域的属性，在高级浏览器中是只读属性，最重要的是它不和任何值相等，包括它自己本身；</p>\n<p>那么如何来判断一个值是否为 NaN 呢？下面的函数可以解决这个问题</p>\n<pre><code class=\"language-js\">function isNaNFn(num) {\n  return typeof num === 'number' &amp;&amp; isNaN(num);\n}\n</code></pre>\n<p><strong>数值转换：</strong></p>\n<p>有三个方法可以将非数值转换成数值：Number()、parseInt()、parseFloat()</p>\n<p>简单说说 Number()和 parseInt()这两个函数的区别吧。前者只接收一个参数，而后者接收两个参数，其中第二个参数为进制数。</p>\n<p>两者最大的不同在于处理字符串：Number()转换空字符串的时候，会返回 0；而 parseInt()为 NaN。</p>\n<p>当字符串不为空的时候，Number()会做很多的判断：</p>\n<p>1、如果字符串中只包含数字，那么就会转换成 10 进制数；</p>\n<p>2、如果有小数点，就会转换成浮点数；</p>\n<p>3、如果包含 16 进制格式，就会将其转换成相同大小的 10 进制数；</p>\n<p>4、如果是空字符串，就会转换成 0；</p>\n<p>5、如果包含上述字符以外的字符，就会转换成 NaN；</p>\n<p>而 parseInt 就不一样，它在转换字符串的时候，更多的是看该字符串是否符合数值模式。它会忽略字符串前面的空格，直到找到第一个非空字符，否则就会返回 NaN（这也是为什么 parseInt 处理空字符串的时候会返回 NaN 的原因所在）如果遇到了非数字字符，就会停止解析后面的字符，比如处理 1234yzh，就会返回 1234；</p>\n<p>因此，在处理整数的时候，我觉得还是使用 parseInt()比较合理;</p>\n<p>parseFloat 是返回浮点数，处理规则和 parseInt 差不多；</p>\n<h5>String 篇</h5>\n<p>字符串应该在任何一门语言中，都占用了很高的使用率，JS 在操作字符串的时候，给我们提供了很多非常有用的函数。</p>\n<p>首先来讲讲字符串的创建，有两种方式：第一使用 String 引用类型，第二种就是直接赋值；</p>\n<pre><code class=\"language-js\">var s1 = new String('test'),\n  s2 = 'test';\nconsole.log(s1 === s2);\n</code></pre>\n<p>大家猜猜，以上的代码执行之后，会输出什么？</p>\n<p>答案是<strong>false</strong></p>\n<p>这是为什么呢？其实道理很简单，因为 s1 和 s2 的数据类型不一样，如果执行的是<code>s1 == s2</code>，就会返回<code>true</code>，因为在执行<code>s1==s2</code>的时候，会发生类型转换。</p>\n<p>大家不妨用 typeof 操作符来执行一下<code>typeof s1</code>和<code>typeof s2</code>，那么答案就很容易明白了！</p>\n<p><strong>下面说说字符串常用的函数</strong></p>\n<p>**访问字符串中特定字符的方法：**charAt()和 charCodeAt()，两者都接收一个数字参数，也就是基于 0 的字符位置; var str = 'Hello world'; console.log( str.charAt( 1 ) );</p>\n<p>上面的结果返回'e'</p>\n<pre><code class=\"language-js\">var str = 'Hello world';\nconsole.log(str.charCodeAt(1));\n</code></pre>\n<p>上面的结果返回：101</p>\n<p><strong>利用 charCodeAt()编写的获取字符串字节的函数：</strong></p>\n<pre><code class=\"language-js\">function getStrBytes(str) {\n  if (typeof str === 'string') {\n    var len = (i = str.length);\n\n    while (i--) {\n      if (str.charCodeAt(i) &gt; 255) {\n        len++;\n      }\n    }\n    return len;\n  }\n  return 0;\n}\n</code></pre>\n<p>调用方法：<code>getStrBytes( '噬魂 123' )</code>;</p>\n<p><strong>字符串的拼接：</strong></p>\n<p><strong>加（+）和加等于（+=）操作符</strong></p>\n<pre><code class=\"language-js\">str += 'one' + 'two';\n</code></pre>\n<p>上面的代码运行的时候，会经过<strong>4</strong>个步骤：</p>\n<p>1、在内存中创建一个临时字符串；</p>\n<p>2、拼接后的字符串“onetwo”被赋值给该临时字符串；</p>\n<p>3、临时字符串与当前 str 拼接；</p>\n<p>4、最后把结果赋值给 str；</p>\n<p>为避免临时字符串的产生，可以用下面的方式实现同样的效果：<code>str = str + 'one' + 'two';</code></p>\n<p><strong>使用函数 concat()</strong></p>\n<pre><code class=\"language-js\">var str = 'hello '.concat('world!');\n</code></pre>\n<p><strong>使用数组（对于字节很长的字符串，是一个比较好的方法！）</strong></p>\n<pre><code class=\"language-js\">var str = ['hello', ' world!'].join('');\n</code></pre>\n<p><strong>三种方式的比较</strong></p>\n<p>这里使用了 firejspt.js，这个小工具还不错，，下载地址：<a href=\"http://code.google.com/p/firejspt/downloads/list\">http://code.google.com/p/firejspt/downloads/list</a></p>\n<pre><code class=\"language-js\">function test2() {\n  var newStr = '',\n    i = 1350000;\n\n  while (i--) {\n    newStr += 'hello' + ' world!';\n  }\n}\n\nfunction test1() {\n  var newStr = '',\n    arr = [],\n    i = 1350000;\n\n  while (i--) {\n    arr.push('hello', ' world!');\n  }\n  newStr = arr.join('');\n}\n\nfunction test3() {\n  var newStr = '',\n    i = 1350000;\n\n  while (i--) {\n    newStr.concat('hello', ' world!');\n  }\n}\n\njspt.test(function() {\n  test1();\n});\n\njspt.test(function() {\n  test2();\n});\n\njspt.test(function() {\n  test3();\n});\n</code></pre>\n<p>执行结果：</p>\n<p>在 ie 和 chrome 下面测试了一下，竟然发现效率最高的是加（+）操作符，看来书上的知识不可尽信，关键还是自己动手去实践。所以还是那句话：<strong>知识是死的，人是活的</strong>，多动手，比死看书有用多了，尽管书本知识也很重要；</p>\n<p>这里有一篇比较好的文章，是外国人写的（ps：不得不说，其实很多时候，还是老外写的东西比较给力！）<a href=\"http://dev.opera.com/articles/view/efficient-javascript/\">这是链接</a></p>\n<p><strong>截取字符串：</strong></p>\n<p>js 中有三个截取字符串的方法：substring()、substr()、以及 slice()</p>\n<p>三者的联系和区别</p>\n<p>当三者都是接受一个参数，并且这个参数为正整数的时候，其实三者是没有啥区别的；</p>\n<pre><code class=\"language-js\">var str = 'hello world';\nconsole.log(str.substring(3));\nconsole.log(str.substr(3));\nconsole.log(str.slice(3));\n</code></pre>\n<p>三者的执行结果都是：<code>'llo world'</code></p>\n<p>当三者都是接受一个参数，并且这个参数为负整数的时候，substring 会把这个负数转换成 0，就相当于 <code>substring(0)；</code>而 substr 和 slice 都是从字符串逆序截取字符串</p>\n<pre><code class=\"language-js\">var str = 'hello world';\nconsole.log(str.substring(3));\nconsole.log(str.substr(3));\nconsole.log(str.slice(3));\n</code></pre>\n<p>上面执行的结果分别为：'hello world'、'rld'、'rld'</p>\n<p>当三者接收两个参数，并且两个参数都是正数的时候，substring 和 slice 的返回结果都一样，而 substr 则不一样。三者的第一个参数都是指位置，substr 的第二个参数表示长度，而 substring 和 slice 都是表示位置；</p>\n<pre><code class=\"language-js\">var str = 'hello world';\nconsole.log(str.substring(3, 7));\nconsole.log(str.substr(3, 7));\nconsole.log(str.slice(3, 7));\n</code></pre>\n<p>上面执行的结果分别为：'lo w'、'lo worl'、'lo w'</p>\n<p>当三者接收两个参数，并且两个参数都是负数的时候，三者的结果都不一样，substring 会把负参数转换成 0，而 substr 也会转换成 0，所以 substr 返回的是空字符串；</p>\n<pre><code>var str = 'hello world';\nconsole.log( str.substring( 3, -4 ) );\nconsole.log( str.substr( 3, -4 ) );\nconsole.log( str.slice( 3, -4 ) );\n</code></pre>\n<p>上面执行的结果分别为：'hel'、''、'lo w'</p>\n<h5>Array 类型</h5>\n<p>数组在 js 中应用也非常广泛，总的来说，因为 js 中没有栈、队列这样的数据结构，很多时候，我们都是用数组来模拟这样的数据结构；</p>\n<p><strong>模拟栈方法：</strong></p>\n<pre><code class=\"language-js\">var colors = [];\n// 入栈\ncolors.push('red', 'green');\n// 出栈\ncolors.pop();\n</code></pre>\n<p><strong>模拟队列方法：</strong></p>\n<pre><code class=\"language-js\">var colors = [];\n// 入队\ncolors.push('red', 'green');\n// 出队\ncolors.shift();\n</code></pre>\n<p>数组中，我认为最强悍的函数就是：<strong>splice()</strong>。它可以删除、插入、替换数组元素；</p>\n<p>具体用法：splice()至少接收<strong>2</strong>个参数，第一个参数代表起始位置，第二个参数代表删除的项数；举个例子</p>\n<pre><code class=\"language-js\">var colors = ['red', 'green', 'yellow'];\nconsole.log(colors.splice(0, 1));\n</code></pre>\n<p>上面的代码会返回：<code>[&quot;green&quot;, &quot;yellow&quot;]</code></p>\n<p>上面的例子是删除的用法，如果要删除第二项，那就是<code>colors.splice( 1, 1 )</code></p>\n<p>其实这个函数最给力的是它可以<strong>插入和替换</strong>数组元素：</p>\n<pre><code class=\"language-js\">var colors = ['red', 'green', 'yellow'];\nconsole.log(colors.splice(0, 0, 'black'));\n</code></pre>\n<p>上面的代码会在 red 元素后面插入 black，返回的结果是：<code>[&quot;black&quot;, &quot;red&quot;, &quot;green&quot;, &quot;yellow&quot;]</code></p>\n<pre><code class=\"language-js\">var colors = ['red', 'green', 'yellow'];\nconsole.log(colors.splice(0, 1, 'black'));\n</code></pre>\n<p>上面的代码会先删除 red 元素，再插入 black，返回的结果是：<code>[&quot;black&quot;, &quot;green&quot;, &quot;yellow&quot;]；</code></p>\n<p>举一个比较有趣的例子：<strong>数组去重问题</strong></p>\n<pre><code class=\"language-js\">Array.prototype.delRepeat = function() {\n  var i = this.length,\n    obj = {};\n\n  while (i--) {\n    if (!obj[this[i]]) {\n      obj[this[i]] = true;\n    } else {\n      this.splice(i, 1);\n    }\n  }\n\n  return this;\n};\n</code></pre>\n<p>上面是在 Array 的原型链添加 delRepeat()方法，调用方法是：arr.delRepeat();</p>\n<h5>Function 类型（函数）</h5>\n<p>**理解参数：**在 ECMAScript 函数里面，即使该函数在定义的时候只接受两个参数，但是调用这个函数的时候，未必要传两个参数，可以一个、两个、三个...</p>\n<p>之所以会这样，是因为 ECMAScript 里面的参数是由内部的一个数组来表示的，也就是 arguments；</p>\n<pre><code class=\"language-js\">function add() {\n  return arguments[0] + arguments[1];\n}\nconsole.log(add(10, 20));\n</code></pre>\n<p>上面会输出：30；</p>\n<p>有一点值得注意，arguments 的值永远会与对应命名的参数的值保持同步。arguments 的长度由传入的参数的个数所决定，没有传递值的参数将会自动被赋值为 undefined；</p>\n<pre><code class=\"language-js\">function add(num1, num2) {\n  arguments[1] = 10;\n  return arguments[0] + num2;\n}\nconsole.log(add(10, 20));\n</code></pre>\n<p>上面会输出：20；</p>\n<p>另外有一点需要特别注意，造成上面的现象出现，并不是因为 num2 和 arguments[1]公用相同的内存空间，相反，<strong>他们的内存空间是独立的</strong>。</p>\n<p>还有就是 arguments 有一个属性：callee，它指向拥有该 arguments 对象的函数。</p>\n<p><strong>没有函数重载：</strong> 如果定义了两个重名的函数，那么后面定义的函数将会覆盖前面定义的函数；对于<strong>没有函数重载</strong>的理解，我觉得可以把函数名想象成指针，这样理解起来就容易许多了。</p>\n<p><strong>关于内部对象 this：</strong> this 对象所引用的是函数执行时的执行环境吧。</p>\n<p>要理解 this 对象，首先要理解作用域链的相关知识。</p>\n<p>实际上，每一个 JS 函数都是一个对象，更确切地说，是 Function 对象的一个实例。Function 对象里面有一个 Scope 的内部属性，这个属性包含的就是函数的作用域链。</p>\n<p>每一个函数被创建的时候，它的作用域链就会填充相关的数据。举个例子（假设它是全局环境下定义的函数）</p>\n<pre><code class=\"language-js\">function sum(num1, num2) {\n  return num1 + num2;\n}\n</code></pre>\n<p>上面的代码中，当 sum 函数被创建的时候，它的 scope 属性里面，也就是它的作用域链里面会填入一个全局对象。</p>\n<p>当调用这个函数的时候，<code>var s = sum( 5, 10 );</code>，就会产生一个<strong>运行期上下文</strong>（函数每次执行，都会产生对应的运行期上下文，函数执行完毕后，运行期上下文就会被销毁。），运行期上下文定义了函数调用的执行环境。当运行期上下文被创建之后，就会复制该函数的 scope 属性中的对象到自己的作用域中，同时生成一个<strong>活动对象</strong>填入自己的作用域中。也就是说，此时该运行期上下文的作用链里面有两个对象，一个是全局对象，一个活动对象。</p>\n<p><img src=\"/static/img/javascript-function-scope.png\" alt=\"javascript-javascfipt-function-scope\"></p>\n<p>值得一提的是，全局对象的访问会排在活动对象的前面，假如要访问某个变量，那么就会先查看活动对象，然后再查看全局对象，因此标识符的优化，在 js 优化中也是重要的一环。</p>\n<p>说到作用域了，也不得不提一下<strong>闭包</strong>，闭包为何物呢？很多同学一直都弄不懂这个概念。（其实，我也是花了很大的经历，才稍微有点点弄懂）。</p>\n<p><strong>闭包：<strong>闭包其实也是函数，只不过闭包比较特殊而已。它是</strong>有能力访问其他函数作用域的函数</strong>。举个例子</p>\n<pre><code class=\"language-js\">function sum(num1, num2) {\n  return function() {\n    return num1 + num2;\n  };\n}\nconsole.log(sum(5, 10)());\n</code></pre>\n<p>从上面的代码来看，sum 函数返回的匿名函数就是一个闭包，为什么说它是闭包呢？原因很简单，因为它访问了 num1 和 num2 了。</p>\n<p>那么这个闭包的作用域是怎么样的呢？</p>\n<p>由上个例子可以知道，创建这个闭包之后，该闭包的作用域链就会填入两个对象：全局对象和 sum 函数执行时的活动对象。当执行这个闭包的时候，闭包本身也是函数，因此它也会创建一个运行期上下文，同时把闭包的作用域链的全局对象和 sum 函数的活动对象填入到自己的作用域链中，同时会生成自己的活动对象，填入到作用域链的最顶端。关系如下图所示：</p>\n<p><img src=\"/static/img/javascript-closure-scope.png\" alt=\"javascript-javascfipt-closure-scope\"></p>\n<p>这里又提到了<strong>匿名函数</strong>，这里也扯一下匿名函数吧。</p>\n<pre><code class=\"language-js\">setTimeout(function() {\n  //some code\n}, 123);\n</code></pre>\n<p>上面的 setTimeout 里面的函数，就是一个匿名函数哈。</p>\n<p>再举个例子，我们经常用到的 jQuery，第一句话就是<code>(function( window, undefined ) {})(window)</code>，这也是一个匿名函数。作用大概是在页面下载代码的过程中就把代码加到执行环境中。</p>\n<p>说起匿名函数，有两点需要记住，第一，它没有名字（呵呵），第二，它的作用域是全局作用域。</p>\n<p>刚刚上网找了一篇文章：<a href=\"http://dancewithnet.com/2008/05/07/javascript-anonymous-function/\">链接</a>。作者绝对是大牛级别的，里面详细介绍了匿名函数。</p>\n<p>（每逢佳节倍思亲，今天是中秋节，大概长这么大第一次自己一个人过中秋节呀，55555...说多了都是泪，继续把这篇博客写完吧！）</p>\n<p>昨天晚上在网上看到了一篇博客，里面提到一道有趣的题目</p>\n<pre><code class=\"language-js\">function test() {\n  this.name = 'taobao';\n  this.waitMes = function() {\n    //隔5秒钟执行this.name\n  };\n}\n</code></pre>\n<p>上面的题目要求是每隔 5 秒钟执行<code>this.name</code>，很明显是要用到<code>setInterval</code>函数。这里也得分一些情况吧，刚看到代码的时候，我还以为有很多面向对象的东西，其实如果没有太多要求，直接执行就好，因为 test 函数是在全局作用域下的，所以就不用考虑<code>setInterval</code>的问题了；</p>\n<pre><code class=\"language-js\">function test() {\n  this.name = 'taobao';\n  this.waitMes = function() {\n    setInterval(function() {\n      console.log(this.name);\n    }, 2000);\n  };\n  this.waitMes();\n}\ntest();\n</code></pre>\n<p>或者，像这样</p>\n<pre><code class=\"language-js\">(function test() {\n  this.name = 'taobao';\n  this.waitMes = function() {\n    setInterval(function() {\n      console.log(this.name);\n    }, 2000);\n  };\n  this.waitMes();\n})();\n</code></pre>\n<p>个人更推荐上面的第二种。上面的第二种是把函数声明转换成函数表达式直接执行的。</p>\n<p>看来苏洋前辈说得对，对于很多 js 的细节，我并没有注意到，刚刚看了一下函数声明和函数表示表达式的区别，这里也扯一下；</p>\n<p>函数声明是类似于下面的代码：</p>\n<pre><code class=\"language-js\">console.log(sum(10, 10));\nfunction sum(num1, num2) {\n  return num1 + num2;\n}\n</code></pre>\n<p>而函数表达式类似于下面这样的：</p>\n<pre><code class=\"language-js\">console.log(sum(10, 10));\nvar sum = function() {\n  return num1 + num2;\n};\n</code></pre>\n<p>看到上面两段代码，很多人（包括今天以前的我）都以为输出的结果是一样的，但是事实上，第二段代码是会报错的，因为 sum 函数在执行<code>sum( 10, 10 )</code>的时候还没有初始化，这就是函数声明和函数表达式的最大区别：<strong>Javascript 引擎会把函数声明提前执行，而函数表达式要等到 Javascript 引擎读取到那段代码之后才执行</strong>；</p>\n<p>类似于这样的写法，就是把函数声明转换成函数表达式： (function() { // some code... })();</p>\n<p>上面的代码其实最大的好处有两个，一个是立刻执行，另外一个就是拥有了<strong>块级作用域</strong>，外部是不能访问到上面函数内部的代码。这又令我想起 jQuery 的开头和结尾的代码<code>(function( window, undefined ) { })( window )</code></p>\n<p>当使用<code>new</code>操作符实例化出一个实例的时候，情况有些特殊，因为<code>new</code>操作符会把 this 指向实例本身，而前文也提到<code>setInterval</code>的作用域是全局作用域的，所以它的 this 指向的是 window 对象，因此在<code>waitMes()</code>函数里面要把<code>this</code>对象赋值给<code>waitMes()</code>函数的局部变量。</p>\n<pre><code class=\"language-js\">function Test() {\n  this.name = 'Yzh';\n  this.waitMes = function() {\n    var self = this;\n    setInterval(function() {\n      console.log(self.name);\n    }, 5000);\n  };\n}\nvar t = new Test();\nt.waitMes();\n</code></pre>\n<p>说到闭包，我们每一个初学者都会遇到下标的问题，在这里我花了一些时间去总结了一下解决的方法。</p>\n<p><strong>闭包下标问题</strong>：请看下面的代码</p>\n<pre><code class=\"language-js\">function createF() {\n  var result = [];\n\n  for (var i = 0; i &lt; 10; i++) {\n    result[i] = function() {\n      console.log(i);\n    };\n  }\n  return result;\n}\nvar r = createF();\nr[1]();\n</code></pre>\n<p>执行 result 数组里面的每一个子函数，控制台打印出来都是 10。首先来分析一下造成上面那种现象的原因吧。首先，result 数组里面的每一个函数都是闭包，这是毋庸置疑的，所以这些函数保存了<code>creatF()</code>函数的活动对象，而活动对象里面的<code>i</code>变量最终的值是 10，所以每一个 result 子函数的结果都是 10；</p>\n<p>那么有什么方法解决呢？本人总结了一些小方法（纯个人兴趣，哈哈）</p>\n<p>1、在每一个 result 子函数里面使用局部变量把 i“存起来”；</p>\n<pre><code class=\"language-js\">function createF() {\n  var result = [];\n\n  for (var i = 0; i &lt; 10; i++) {\n    result[i] = function() {\n      var r = i;\n      console.log(r);\n    };\n  }\n  return result;\n}\n</code></pre>\n<p>2、加一层闭包，i 以函数参数形式传递给内层函数函数；</p>\n<pre><code class=\"language-js\">function createF() {\n  var result = [];\n\n  for (var i = 0; i &lt; 10; i++) {\n    result[i] = (function(num) {\n      return function() {\n        console.log(num);\n      };\n    })(i);\n  }\n  return result;\n}\n</code></pre>\n<p>3、使用 Function 对象实例化出一个函数；</p>\n<pre><code class=\"language-js\">function createF() {\n  var result = [];\n\n  for (var i = 0; i &lt; 10; i++) {\n    result[i] = new Function('console.log(' + i + ');');\n  }\n  return result;\n}\n</code></pre>\n<p>目前只发现以上三种写法，至于其他的，其实就是上面三种演变过来的。</p>\n<p>（下面的内容请看《基础篇-Javascript 面向对象》）</p>\n"}}}]);