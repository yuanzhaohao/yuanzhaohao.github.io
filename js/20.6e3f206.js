(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[20],{77:function(t,e){t.exports={markdown:"<h2>React setState 流程解析</h2>\n<blockquote>\n<p>React 作为目前最热门的前端开发框架，实现了 model 和 View 的单向数据绑定，在修改数据的同时，实现了 View 层的刷新，大大简化了我们的操作。这个特性主要归功于<code>setState()</code>方法。本人主要来探寻一下 setState 的流程。</p>\n</blockquote>\n<p>举一个最经典的例子。</p>\n<pre><code class=\"language-js\">incrementCount() {\n  this.setState({count: this.state.count + 1});\n}\n\nhandleSomething() {\n  this.incrementCount();\n  this.incrementCount();\n  this.incrementCount();\n}\n</code></pre>\n<p>在上面的代码里，我们希望执行完<code>handleSomething()</code>之后，<code>this.state.count</code>能递加 3，然鹅最后结果只增加了 1。为了解决上面的问题，可以传递一个函数来访问当前的 state 值，从而链式地进行更新，确保他们是一个建立在另一个之上的，这样就能得到最初想要的结果了。</p>\n<pre><code class=\"language-js\">incrementCount() {\n  this.setState((state) =&gt; {\n    return {count: state.count + 1}\n  });\n}\n\nhandleSomething() {\n  this.incrementCount();\n  this.incrementCount();\n  this.incrementCount();\n}\n</code></pre>\n<p>那么为什么会产生上面这样的现象呢？原因就是<code>setState</code>方法。React 组件是靠单向数据流构建页面的，除了 props 之外，自身的 state 也是改变状态引起组件渲染的主要因素。为了节省消耗，setState 方法有自己的一套更新策略，目的是为了减少 state 更新对页面渲染的消耗。</p>\n<p>我们可以看下 setState 的代码。(from react 16.9.0 <code>packages/react/src/ReactBaseClasses.js</code>)</p>\n<pre><code class=\"language-js\">Component.prototype.setState = function(partialState, callback) {\n  invariant(\n    typeof partialState === 'object' || typeof partialState === 'function' || partialState == null,\n    'setState(...): takes an object of state variables to update or a ' +\n      'function which returns an object of state variables.',\n  );\n  this.updater.enqueueSetState(this, partialState, callback, 'setState');\n};\n</code></pre>\n<p>从上面可以看出，setState 的核心是<code>updater.enqueueSetState</code>方法。这里的<code>updater</code>是<code>renderer</code>在渲染时注入的对象，而这个对象是<code>reconciler</code>提供的。</p>\n<p>未完待续。。。</p>\n"}}}]);