(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[24],{134:function(n,a){n.exports={markdown:"<h2>seajs 写的一个例子</h2>\n<blockquote>\n<p>昨天晚上花时间写了一个 seajs 的 demo，下面简单介绍一下！因为还是第一次使用 seajs 开发，所以有很多细节的东西，我觉得运用得还不是很熟练。总的来说包括三个对象，一个是布局 Layout 对象，另外一个是弹出层 Dialog 对象，最后一个是 highcharts 对象（主要用于在 dialog 弹出层里面加内容的）。</p>\n</blockquote>\n<h4>布局 Layout 对象</h4>\n<p>这个布局，总的来说，是参考了我之前做的一个<a href=\"http://yzh.ap01.aws.af.cm/\">网页版简历</a>来写的（其实之前做的这个网页版简历还有不少地方需要改进，如果有时间，希望能用自己最近学习的 seajs 和 angularjs 的知识用到这个网页版简历里面去，但马上就要投入战斗了，都不知道有木有时间去重构代码呢！）</p>\n<p>ps：有点小后悔，有一段时间没有使用 gruntjs 了，一不小心吧源文件也压缩了，结果只能到<a href=\"http://jsbeautifier.org/\">jsbeautifier</a>还原了，但代码风格和我写得有很大的不同了，哎，看来以后写代码的时候，如果代码量比较大，还是记得备份代码，不然出现错误操作了，那就悲剧了。（还好今天是写 demo）另外，seajs 也有一个专门的项目构建工具 SPM，如果项目遵循推荐的标准目录结构，貌似还蛮简单的。（因为这个 demo 的目录并不是 seajs 官方推荐的，今天就先不用 SPM 构建了，改天再用吧！）</p>\n<pre><code class=\"language-js\">// layout.js\ndefine(function(a, b, c) {\n  function d(a, b, c, d) {\n    (this.prevBtn = e(a)), (this.nextBtn = e(b)), (this.item = e(c).children()), (this.menu = e(d));\n  }\n  var e = a('jquery');\n  (d.prototype = {\n    constructor: d,\n    init: function() {\n      var a = this.prevBtn,\n        b = this.nextBtn,\n        c = this.item,\n        d = this.menu;\n      a.bind('click', function() {\n        if ((c.stop(!1, !0), !c.is(':animated'))) {\n          c.animate(\n            {\n              left: '+=1124px',\n            },\n            300,\n          ).animate(\n            {\n              left: '-=100px',\n            },\n            300,\n          );\n          var e = c.eq(3).css('left');\n          switch (e) {\n            case '0px':\n              b.show();\n              break;\n            case '2048px':\n              a.hide();\n          }\n          d.find('.active')\n            .removeClass('active')\n            .prev()\n            .addClass('active');\n        }\n        return !1;\n      }),\n        b.bind('click', function() {\n          if ((c.stop(!1, !0), !c.is(':animated'))) {\n            c.animate(\n              {\n                left: '-=1124px',\n              },\n              300,\n            ).animate(\n              {\n                left: '+=100px',\n              },\n              300,\n            );\n            var e = c.eq(0).css('left');\n            switch (e) {\n              case '-2048px':\n                b.hide();\n                break;\n              case '0px':\n                a.show();\n            }\n            d.find('.active')\n              .removeClass('active')\n              .next()\n              .addClass('active');\n          }\n          return !1;\n        }),\n        d.delegate('li', 'click', function() {\n          var f = e(this),\n            g = f.index(),\n            h = d.find('.active').index(),\n            i = h - g;\n          if (\n            (f\n              .addClass('active')\n              .siblings()\n              .removeClass('active'),\n            c.stop(!1, !0),\n            !c.is(':animated'))\n          )\n            switch (\n              (c\n                .animate(\n                  {\n                    left: '+=' + 1074 * i,\n                  },\n                  300,\n                )\n                .animate(\n                  {\n                    left: '-=' + 50 * i,\n                  },\n                  400,\n                ),\n              g)\n            ) {\n              case 3:\n                b.hide(), a.show();\n                break;\n              case 0:\n                b.show(), a.hide();\n                break;\n              default:\n                b.show(), a.show();\n            }\n        });\n    },\n  }),\n    (c.exports = d);\n});\n</code></pre>\n<p>大概的原理就是在 layout 这个模块里面定义一个对象，最后通过<code>module.exports</code>对外输出这个对象。</p>\n<p>调用的方法如下（可参考入口模块<code>main.js</code>）： // 调用布局对象 // @param1：向左滚动按钮 // @param2：向右滚动按钮 // @param3：主体内容 // @param4：头部菜单按钮 var layout = new Layout( &quot;#prev-btn&quot;, &quot;#next-btn&quot;, &quot;#play&quot;, &quot;#menu&quot; ); layout.init();</p>\n<h4>弹出层 dialog 对象</h4>\n<p>代码稍微简单一些：</p>\n<pre><code class=\"language-js\">define(function(require, exports, module) {\n  var $ = require('jquery');\n\n  function Dialog(play, dialog, mask, close) {\n    this.play = $(play);\n    this.dialog = $(dialog);\n    this.mask = $(mask);\n    this.close = $(close);\n  }\n\n  Dialog.prototype = {\n    constructor: Dialog,\n\n    init: function() {\n      var play = this.play,\n        close = this.close,\n        dialog = this.dialog,\n        mask = this.mask;\n\n      close.bind('click', function() {\n        dialog.hide();\n        mask.hide();\n      });\n\n      mask.bind('click', function() {\n        dialog.hide();\n        $(this).hide();\n      });\n\n      play.delegate('button', 'click', function(event) {\n        dialog.show();\n        mask.show();\n      });\n    },\n  };\n\n  module.exports = Dialog;\n});\n</code></pre>\n<p>实现的原理和上面一样，调用方法如下：</p>\n<pre><code class=\"language-js\">// 调用调用弹出层对象\n// @param1：主体内容\n// @param2：弹出层\n// @param3：透明层\n// @param4：关闭弹出层的按钮\nvar dialog = new Dialog('#play', '#dialog', '#dialog-mask', '#close');\ndialog.init();\n</code></pre>\n<h4>图表 chart 对象</h4>\n<pre><code class=\"language-js\">define(function(require, exports, module) {\n  var $ = require('jquery');\n\n  require('highcharts');\n  require('highcharts-more');\n\n  function Chart(play, content) {\n    this.button = $(play).find('button');\n    this.content = $(content);\n  }\n\n  Chart.prototype = {\n    constructor: Chart,\n    data: require('./chartData'),\n\n    init: function() {\n      var button = this.button,\n        content = this.content,\n        data = this.data;\n\n      $.each(button, function(k, v) {\n        $(this).bind('click', function() {\n          content.highcharts(data[k]);\n        });\n      });\n    },\n  };\n  module.exports = Chart;\n});\n</code></pre>\n<p>调用方法如下：</p>\n<pre><code class=\"language-js\">// 调用调用图表对象\n// @param1：主体内容\n// @param2：弹出层内容\nvar chart = new Chart('#play', '#content');\nchart.init();\n</code></pre>\n<h4>写在最后</h4>\n<p><strong>关于学习新的东西：<strong>现在前端这个领域（也不仅仅是前端这个领域吧，计算机很多领域都是这样）可以用一个词语来形容，那就是</strong>日新月异</strong>。几乎每隔一段时间，都会出现一些之前从未听过的东西。</p>\n<p>对于这些新东西，我觉得不能刻意去追求这些新东西，因为这些光鲜亮丽，华而不实的东西，说不定哪一天就过时了。对于这么多的新东西，我觉得要慎重去选择，选择一些有知名度的、对自己的开发有所帮助的、在很长一段时间不会“过时”的东西来学，这样才有意义。</p>\n<p>同时，有一点，我觉得非常重要，那就是<strong>基础</strong>，基础就像功夫片里面的内功一样，内功练好了，武功就很容易练了。放弃对基础的学习，而跑去学习一些“新东西”，这是一种舍本逐末的行为，非常不可取的，呵呵</p>\n<p>曾经在一篇博客上面看到一句话：<strong>毕业真正考量的不是学到了多少东西，而是是否有足够强大的学习能力。</strong></p>\n<p>所以，在这句话的基础上，我想再加一句：<strong>强大的学习能力取决于是否有强大的基础。</strong></p>\n"}}}]);